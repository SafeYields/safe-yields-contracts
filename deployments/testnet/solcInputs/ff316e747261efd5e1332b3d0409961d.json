{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n *\n * _Available since v3.1._\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` tokens of token type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the amount of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(address[] calldata accounts, uint256[] calldata ids)\n        external\n        view\n        returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers `amount` tokens of token type `id` from `from` to `to`.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `amount`.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 id,\n        uint256 amount,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * Emits a {TransferBatch} event.\n     *\n     * Requirements:\n     *\n     * - `ids` and `amounts` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata amounts,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/ISafeNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.17;\n\nimport \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\n//  ____         __       __   ___      _     _\n//  /___|  __ _ / _| ___  \\ \\ / (_) ___| | __| |___\n// \\___ \\ / _` | |_ / _ \\  \\ V /| |/ _ \\ |/ _` / __|\n//  ___) | (_| |  _|  __/   | | | |  __/ | (_| \\__ \\\n// |____/ \\__,_|_|  \\___|   |_| |_|\\___|_|\\__,_|___/\n\n/// @title  ISafeVault\n/// @author crypt0grapher\n/// @notice Safe Yield Vault depositing to the third-party yield farms\ninterface ISafeNFT is IERC1155 {\n    enum Tiers {Tier1, Tier2, Tier3, Tier4}\n\n    event TogglePresale(bool _status);\n\n    /**\n    *   @notice purchase Safe NFT for exact amount of USD\n    *   @param _tier tier of the NFT to purchase which stands for ERC1155 token id [0..3]\n    *   @param _amount amount of USD to spend\n    *   @param _referral referral getting 5% of the price, should not be the sender, if not specified, goes to treasury\n    */\n    function buy(Tiers _tier, uint256 _amount, address _referral) external;\n\n    /**\n    *   @notice distribute profit among the NFT holders, the function fixes the amount of the reward and the NFT holders and their shares at the moment of the call. It does not transfer the reward to the NFT holders, it just records the amount of the reward for each NFT holder.\n    *   @param _amountUSD amount of USD to distribute\n    */\n    function distributeProfit(uint256 _amountUSD) external;\n\n    /**\n    *   @notice the function calculates the amount of the reward for the NFT holder and transfers it to the NFT holder\n    */\n    function claimReward() external;\n\n    /**\n    *   @notice gets NFT balance for all tiers\n    */\n    function getMyBalanceTable() external view returns (uint256[] memory);\n\n    /**\n    *   @notice toggles presale status\n    */\n    function togglePresale() external;\n\n    /**\n    *   @notice sets all discounted NFT prices\n    *   @param _presalePrice percent to multiply to get the discounted price, e.g. 90 for 10% discount, percent format is determined by the multiplier\n    */\n    function setDiscountedPrice(uint256 _presalePrice) external;\n\n\n    /**\n    *   @notice gets NFT balance for all tiers\n    */\n    function getBalanceTable(address _user) external view returns (uint256[] memory);\n\n\n    /**\n    *   @notice gets NFT price for all tiers in USD\n    ///todo in SAFE!\n    */\n    function getFairPriceTable() external view returns (uint256[] memory);\n\n\n    /**\n    *   @notice gets all NFT prices in USD, the original ones without discounts\n    *   @return uint256[] containing all NFT prices in one table in USD\n    */\n    function getPriceTable() external view returns (uint256[] memory);\n\n    /**\n    *   @notice gets all discounted NFT prices in USD, for presale for all 4 weeks of the presale\n     *   @return uint256 containing percent to multiply to the price to get a discount\n    */\n    function discountedPrice() external view returns (uint256);\n\n\n\n    /**\n    *   @notice gets NFT price in USD\n    *   @return NFT price in USD\n    */\n    function getPrice(Tiers _tier) external view returns (uint256);\n\n\n    /**\n    *   @notice gets NFT fair price in USD\n    *   @return counts not only the sale price but also share of the profit for the tier\n    */\n    function getFairPrice(Tiers _tier) external view returns (uint256);\n\n    /**\n    *   @notice gets the current distribution number\n    *   @return current distribution number, the one that assigned to the latest distribution\n    */\n    function currentDistributionId() external view returns (uint256);\n\n    /**\n    *   @notice undistributed profit amount in USD\n    *   @return amount of the rewards not yet distributed to NFT holders\n    */\n    function getUnclaimedRewards() external view returns (uint256);\n\n\n    /**\n    *   @notice returns the amount of the reward share for the NFT holder\n    */\n    function getPendingRewards(address _user, uint256 _distributionId) external view returns (uint256);\n\n    /**\n    *   @notice **Your NFTs (% Treasury) **is calculated in $ as a relation of total price of NFTs possessed by the $ amount of Investment Pool - including its SAFE and stable coin  components.\n    */\n    function getMyShareOfTreasury() external view returns (uint256);\n\n    /**\n    *   @notice returns the weighted balance of the user across all tiers\n    */\n    function votingPower(address _user) external view returns (uint256);\n\n}\n"
    },
    "contracts/interfaces/IVotingDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IVotingDAO {\n    event ProposalAdded(uint indexed proposalId, string description);\n    event VoteCasted(uint indexed proposalId, address indexed voter, uint indexed vote);\n    event ProposalClosed(uint indexed proposalId);\n\n    enum Status {Open, Closed}\n    enum Vote {NoVote, Yes, No}\n\n    struct Proposal {\n        string description;\n        uint yesVotes;\n        uint noVotes;\n        Status status;\n        mapping(address => Vote) votesByMember;\n    }\n\n    /**\n    @notice This function adds a new proposal to the list of proposals.\n    @param _description The description of the proposal.\n    */\n    function addProposal(string memory _description) external;\n\n    /**\n    @notice This function allows Safe NFT owners to vote on a proposal.\n    @param _proposalId The ID of the proposal.\n    @param _vote The vote (Yes 1 or No 2).\n    */\n    function vote(uint _proposalId, Vote _vote) external;\n\n    /**\n    @notice This function allows the admin to close a proposal.\n    @param _proposalId The ID of the proposal.\n    */\n    function closeProposal(uint _proposalId) external;\n\n    /**\n    @notice This function returns the details of a proposal.\n    @param _proposalId The ID of the proposal.\n    @return description The description of the proposal.\n    @return yesVotes The number of yes votes.\n    @return noVotes The number of no votes.\n    @return status The status of the proposal (Open or Closed).\n    */\n    function getProposal(uint _proposalId) external view returns (string memory description, uint yesVotes, uint noVotes, Status status);\n}\n"
    },
    "contracts/VotingDAO.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./interfaces/ISafeNFT.sol\";\nimport \"hardhat-deploy/solc_0.8/proxy/Proxied.sol\";\nimport \"./interfaces/IVotingDAO.sol\";\n\ncontract VotingDAO is IVotingDAO, Proxied {\n    ISafeNFT public safeNFT;\n\n    Proposal[] public proposals;\n\n    modifier onlySafeNFTOwner() {\n        require(safeNFT.votingPower(msg.sender) > 0, \"Only Safe NFT owners can call this function\");\n        _;\n    }\n\n    function initialize(address _safeNFT) public proxied {\n        safeNFT = ISafeNFT(_safeNFT);\n    }\n    constructor (address _safeNFT) {\n        initialize(_safeNFT);\n    }\n\n\n    function addProposal(string memory _description) public onlyProxyAdmin {\n        proposals.push();\n        Proposal storage proposal = proposals[proposals.length - 1];\n        proposal.description = _description;\n        proposal.status = Status.Open;\n        emit ProposalAdded(proposals.length - 1, _description);\n    }\n\n    function vote(uint _proposalId, Vote _vote) public onlySafeNFTOwner {\n        Proposal storage proposal = proposals[_proposalId];\n\n        require(proposal.status == Status.Open, \"Proposal is not open\");\n        require(proposal.votesByMember[msg.sender] == Vote.NoVote, \"You have already voted\");\n\n        if (_vote == Vote.Yes) {\n            proposal.yesVotes += safeNFT.votingPower(msg.sender);\n        } else if (_vote == Vote.No) {\n            proposal.noVotes += safeNFT.votingPower(msg.sender);\n        } else\n            revert(\"Invalid vote, only Yes (1) or No (2)\");\n        proposal.votesByMember[msg.sender] = _vote;\n        emit VoteCasted(_proposalId, msg.sender, uint(_vote));\n    }\n\n    function closeProposal(uint _proposalId) public onlyProxyAdmin {\n        Proposal storage proposal = proposals[_proposalId];\n\n        require(proposal.status == Status.Open, \"Proposal is not open\");\n\n        proposal.status = Status.Closed;\n        emit ProposalClosed(_proposalId);\n    }\n\n    function getProposal(uint _proposalId) public view returns (string memory description, uint yesVotes, uint noVotes, Status status) {\n        Proposal storage proposal = proposals[_proposalId];\n        return (proposal.description, proposal.yesVotes, proposal.noVotes, proposal.status);\n    }\n\n}\n"
    },
    "hardhat-deploy/solc_0.8/proxy/Proxied.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract Proxied {\n    /// @notice to be used by initialisation / postUpgrade function so that only the proxy's admin can execute them\n    /// It also allows these functions to be called inside a contructor\n    /// even if the contract is meant to be used without proxy\n    modifier proxied() {\n        address proxyAdminAddress = _proxyAdmin();\n        // With hardhat-deploy proxies\n        // the proxyAdminAddress is zero only for the implementation contract\n        // if the implementation contract want to be used as a standalone/immutable contract\n        // it simply has to execute the `proxied` function\n        // This ensure the proxyAdminAddress is never zero post deployment\n        // And allow you to keep the same code for both proxied contract and immutable contract\n        if (proxyAdminAddress == address(0)) {\n            // ensure can not be called twice when used outside of proxy : no admin\n            // solhint-disable-next-line security/no-inline-assembly\n            assembly {\n                sstore(\n                    0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103,\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n                )\n            }\n        } else {\n            require(msg.sender == proxyAdminAddress);\n        }\n        _;\n    }\n\n    modifier onlyProxyAdmin() {\n        require(msg.sender == _proxyAdmin(), \"NOT_AUTHORIZED\");\n        _;\n    }\n\n    function _proxyAdmin() internal view returns (address ownerAddress) {\n        // solhint-disable-next-line security/no-inline-assembly\n        assembly {\n            ownerAddress := sload(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103)\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 250
    },
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "evmVersion": "berlin",
    "metadata": {
      "useLiteralContent": true
    }
  }
}